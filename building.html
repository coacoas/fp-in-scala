<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Building A Program</title>
<meta name="author" content="(Bill Carlson)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/css/theme/sky.css" id="theme"/>

<link rel="stylesheet" href="./reveal.js/lib/css/zenburn.css"/>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1>Building A Program</h1>
</section>

</section>
</section>
<section>
<section id="slide-org4e39427">
<h3 id="org4e39427">About Me</h3>
<div class="outline-text-3" id="text-org4e39427">
</div>
</section>
<section id="slide-orgd1edc8d">
<h4 id="orgd1edc8d">Bill Carlson</h4>
</section>
<section id="slide-orgfc81358">
<h4 id="orgfc81358">Cotiviti Labs</h4>
</section>
<section id="slide-org5194349">
<h4 id="org5194349"><a href="https://www.facebook.com/BungalowJax/">The Bungalow</a></h4>
<img src="bungalow.png" width="400"/>

</section>
</section>
<section>
<section id="slide-orgb213151">
<h3 id="orgb213151">Last Time in "Functional Programming"</h3>
<ul class="fragment">
<li>Programming with functions</li>

</ul>
<ul class="fragment">
<li>Referential transparency</li>

</ul>

</section>
<section >

<p>
A program is <i>evaluated</i> by repeated substitution of function calls with the values they represent. 
</p>

</section>
<section >

<p>
The code is simply an interpreter for a particular algebra.  The program is the data that gets evaluated. 
</p>

</section>
<section >

<p>
But how do you actually <i>build</i> the program? 
</p>

</section>
</section>
<section>
<section id="slide-org0776dfe">
<h2 id="org0776dfe">Data Types Revisited</h2>
<p>
Standard Types
</p>
<ul>
<li><code>Int</code></li>
<li><code>String</code></li>

</ul>

<p>
Higher-Kinded Types
</p>
<ul>
<li><code>Option[A]</code></li>
<li><code>List[A]</code></li>
<li><code>Either[E, A]</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-org5f0685f">
<h2 id="org5f0685f">Typeclasses</h2>
<div class="outline-text-2" id="text-org5f0685f">
</div>
</section>
<section id="slide-org94c023b">
<h4 id="org94c023b">Typeclasses</h4>
<ul>
<li>Typeclasses are a mechanism to allow for <b>ad-hoc polymorphism</b></li>
<li>The typeclass declares an interface</li>
<li>THe instance defines the operations</li>

</ul>

</section>
<section id="slide-org8fa0227">
<h4 id="org8fa0227">Typeclasses allow you to modify behavior of code you don't own.</h4>

</section>
<section id="slide-orge6dfe23">
<h4 id="orge6dfe23">Typeclasses</h4>
<div class="org-src-container">

<pre><code class="scala" >trait Show[A] { 
  def show(a: A): String
}
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment"><code class="scala" >implicit val stringShow = new Show[String] {
  def show(s: String) = s
}
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment"><code class="scala" >implicit val addressShow = new Show[Address] {
  def show(addr: Address) = 
    s"""|${addr.street}
        |${addr.city} ${addr.state} ${addr.zip}""".stripMargin
}
</code></pre>
</div>

</section>
<section id="slide-orgff15237">
<h4 id="orgff15237">Typeclasses</h4>
<div class="org-src-container">

<pre><code class="scala" >// A polymorphic function that works only when there is an implicit 
// instance of Show[A] available
def log[A](a: A)(implicit s: Show[A]) = println(s.show(a))
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment"><code class="scala" >object Show { 
  def apply[A] = implicitly[Show[A]]
}
def log[A : Show](a: A) = println(Show[A].show(a))
</code></pre>
</div>


</section>
</section>
<section>
<section id="slide-org4d5a2fe">
<h2 id="org4d5a2fe">Algebraic Combinators</h2>
<div class="outline-text-2" id="text-org4d5a2fe">
</div>
</section>
</section>
<section>
<section id="slide-org6becbc0">
<h3 id="org6becbc0">Monoid</h3>
<div class="org-src-container">

<pre><code class="scala" >trait Monoid[A] { 
  val zero: A
  def append(a: A, b: A)): A
}
</code></pre>
</div>

</section>
<section id="slide-org0c77146">
<h4 id="org0c77146">String concatenation</h4>
<div class="org-src-container">

<pre><code class="scala" >val stringConcat = new Monoid[String] { 
  val zero: String = ""
  def append(a: String, b: String)) = a + b
}
</code></pre>
</div>

</section>
<section id="slide-org0add538">
<h4 id="org0add538">Integer Addition</h4>
<div class="org-src-container">

<pre><code class="scala" >val additionMonoid = new Monoid[Int] { 
  val zero: Int = 0
  def append(a: Int, b: Int)) = a + b
}
</code></pre>
</div>

</section>
<section id="slide-orga4b9dfd">
<h4 id="orga4b9dfd">Integer Multiplication</h4>
<div class="org-src-container">

<pre><code class="scala" >val multiplicationMonoid = new Monoid[Int] { 
  val zero: Int = 1
  def append(a: Int, b: Int)) = a * b
}
</code></pre>
</div>

</section>
<section id="slide-org6a7ccd7">
<h4 id="org6a7ccd7">Laws</h4>
<p>
Right Identity
</p>
<div class="org-src-container">

<pre><code class="scala" >append(a, zero) == a  
</code></pre>
</div>
<p>
Left Identity
</p>
<div class="org-src-container">

<pre><code class="scala" >append(zero, a) == a
</code></pre>
</div>
<p>
Associativity
</p>
<div class="org-src-container">

<pre><code class="scala" >append(a, append(b, c)) === append(append(a, b), c)
</code></pre>
</div>

</section>
<section id="slide-orgb0559c8">
<h4 id="orgb0559c8">Option</h4>
<div class="org-src-container">

<pre><code class="scala" >def optionMonoid[A : Monoid] = new Monoid[Option[A]] { 
  val zero: Int = None
  def append(a: Option[A], b: Option[A])) = a match { 
    case None => b
    case Some(x) => b match { 
      case None => a
      case Some(y) => Some(implicitly[Monoid[A]].append(x, y))
    }
  }
}

optionMonoid[Int].append(Some(3), Some(4)) == Some(7)
optionMonoid[Int].append(Some(3), None) == Some(3)
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orgeb790bf">
<h3 id="orgeb790bf">Foldable</h3>
<div class="org-src-container">

<pre><code class="scala" >trait Foldable[F[_]] {
  def fodlLeft[A, B](a: F[A])(z: B)(f: (B, A) => B): B
  def foldRight[A, B](a: F[A])(z: B)(f: (A, B) => B): B
  def foldMap[A, B : Monoid](a: F[A])(f: A => B): B = 
    foldLeft(a)(Monoid[B].empty)((b, a) => Monoid[B].append(b, f(b)))
}
</code></pre>
</div>

</section>
<section id="slide-org2987378">
<h4 id="org2987378">Combine</h4>
<div class="org-src-container">

<pre><code class="scala" >def combine[F[_], A : Monoid](a: F[A]): A = 
  Foldable[F].foldMap(a)(identity)

combine(List(1, 2, 3, 4)) // 10
combine(List("how", "now", "brown", "cow")  // "hownowbrowncow"
</code></pre>
</div>

</section>
<section id="slide-orgaa8c461">
<h4 id="orgaa8c461">Count</h4>
<div class="org-src-container">

<pre><code class="scala" >def count[F[_], A : Monoid](a: F[A]): A = 
  Foldable[F].foldMap(a)(_ => 1)

count(Some(4)) // 1
count(None)    // 0
count(List(1,2,3,4)) // 4
</code></pre>
</div>


</section>
</section>
<section>
<section id="slide-orgbf95e64">
<h3 id="orgbf95e64">Functor</h3>
<div class="org-src-container">

<pre><code class="scala" >trait Functor[F[_]] { 
  def map[A, B](a: F[A], f: A => B): F[B]
}
</code></pre>
</div>

</section>
<section id="slide-org2511f75">
<h4 id="org2511f75">Which means?</h4>
<p>
<code>map</code> allows you to modify the values within a context without modifying the shape of the context
</p>

</section>
<section id="slide-org92f9e4e">
<h4 id="org92f9e4e">What does <i>that</i> mean?</h4>
<div class="org-src-container">

<pre><code class="scala" >Functor[Option].map(Some(4), (_: Int) * 2) === Some(8)
Functor[Option].map(None, (_: Int) * 2) === None
</code></pre>
</div>
<div class="org-src-container">

<pre><code class="scala" >Functor[List].map(List(1, 2, 3, 4), (_: Int) * 2) === List(2, 4, 6, 8)
Functor[List].map(List.empty[Int], (_: Int) * 2) === List()
</code></pre>
</div>

</section>
<section id="slide-orgdec9887">
<h4 id="orgdec9887">Laws</h4>
<p>
Identity
</p>
<div class="org-src-container">

<pre><code class="scala" >F.map(a)(identity) == a
</code></pre>
</div>
<p>
Composition
</p>
<div class="org-src-container">

<pre><code class="scala" >F.map(F.map(a)(f))(g) == F.map(a)(f compose g)
</code></pre>
</div>
<div class="org-src-container">

<pre class="fragment"><code class="scala" >a.map(f).map(g) == a.map(f andThen g)
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org24553e3">
<h3 id="org24553e3">Applicative</h3>
<p>
Because not every function has one argument&#x2026; 
</p>

</section>
<section >

<p>
What happens if you have a function 
</p>
<div class="org-src-container">

<pre><code class="scala" >f: (A, B) => C
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment"><code class="scala" >Functor[Option].map(Some(3), f)
// error: type mismatch;
//  found   : (Int, Int) => Int
//  required: Int => ?
</code></pre>
</div>

</section>
<section >

<div class="org-src-container">

<pre><code class="scala" >f.curried // (a: Int) => (b: Int) => f(a, b)
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment"><code class="scala" >Functor[Option].map(Some(3), f.curried)
// Some[Int => Int]
</code></pre>
</div>

</section>
<section id="slide-orgba46c72">
<h4 id="orgba46c72">Applicative</h4>
<div class="org-src-container">

<pre><code class="scala" >trait Apply[F[_]] { 
  def ap[A, B](a: F[A], b: F[A => B]): F[B]
}
</code></pre>
</div>

<div class="org-src-container">

<pre class="fragment"><code class="scala" >val sum = (a: Int, b: Int) => a + b
val fOption: Option[Int => Int] = Functor[Option].map(Some(3), sum.curried)

Applicative[Option].ap(Some(4), fOption)
// res4: Option[Int] = Some(7)

Some(4) <*> fOption 
</code></pre>
</div>

</section>
<section id="slide-org83a7b49">
<h4 id="org83a7b49">Extensions</h4>
<div class="org-src-container">

<pre><code class="scala" >trait Applicative[F[_]] extends Apply[F] with  Functor[F] { 
  def pure[A](a: A): F[A]

  def map2[A, B, C](
    a: F[A], 
    b: F[B], 
    c: (A, B) => C): F[C] = 
    ap(b, Fucntor[A].map(a, c.curried))
}
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orgb54fdab">
<h3 id="orgb54fdab">Monad</h3>
<div class="outline-text-3" id="text-orgb54fdab">
</div>
</section>
<section id="slide-orgae5e884">
<h4 id="orgae5e884">Monad</h4>
<p>
It's really not that scary
</p>

</section>
<section id="slide-orgac26fed">
<h4 id="orgac26fed">Monad</h4>
<pre  class="example">
trait Monad[F[_]] extends Applicative[F] {
  def flatMap[A, B](a: F[A])(f: A =&gt; F[B]): F[B]
}
</pre>

</section>
<section id="slide-org41572b6">
<h4 id="org41572b6">Why?</h4>
<pre  class="example">
def getUser(id: String): Option[User]
def getAddress(user: User): Option[Address]

def getAddressForId(id: Sting) = 
  getUser(id).flatMap { user =&gt; 
    getAddress(user)
  }

</pre>

<p class="fragment">
This gets ugly really fast. 
</p>

</section>
<section id="slide-org973fd65">
<h4 id="org973fd65">for-comprehension</h4>
<ul>
<li>Syntactic sugar built into the Scala compiler.</li>
<li>Similar construct (do-notation) exists in Haskell</li>

</ul>
<pre  class="example">
def getPOBoxForId(id: String) = for { 
  user    &lt;- getUser(id)
  address &lt;- getAddress(user)
  pobox   &lt;- getPOBox(address)
} yield address
</pre>

</section>
<section id="slide-orga93202a">
<h4 id="orga93202a">Laws</h4>
<p>
Left Identity
</p>
<div class="org-src-container">

<pre><code class="scala" >pure(a).flatMap(f) == f(a)
</code></pre>
</div>
<p>
Right Identity
</p>
<div class="org-src-container">

<pre><code class="scala" >m.flatMap(pure) == m
</code></pre>
</div>
<p>
Associativity
</p>
<div class="org-src-container">

<pre><code class="scala" >flatMap(flatMap(m)(f))(g) == flatMap(m)(x => flatMap(f(x))(g))
</code></pre>
</div>
<div class="org-src-container">

<pre class="fragment"><code class="scala" >(m >>= f) >>= g == m >>= (x => f(x) >>= g)
</code></pre>
</div>

</section>
<section id="slide-org1d72ded">
<h4 id="org1d72ded">Examples</h4>
<div class="org-src-container">

<pre><code class="scala" >implicit val optionMonad = new Monad[Option] { 
  def flatMap[A, B](a: Option[A])(f: A => Option[B]) = a match { 
    case None => None
    case Some(x) => f(x)
  }
}
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org6a15a27">
<h3 id="org6a15a27">Monads are your friends</h3>
<div class="outline-text-3" id="text-org6a15a27">
</div>
</section>
<section id="slide-orgdbdf75e">
<h4 id="orgdbdf75e">Popular Monads</h4>
<ul>
<li>Option</li>
<li>Either</li>
<li>List</li>

</ul>
<ul class="fragment">
<li>But wait! There's more!</li>

</ul>

</section>
<section id="slide-orgca785a6">
<h4 id="orgca785a6">Reader</h4>
<div class="org-src-container">

<pre><code class="scala" >Reader[I, A]

I => A
</code></pre>
</div>
</section>
<section id="slide-org01e0281">
<h4 id="org01e0281">Writer</h4>
<div class="org-src-container">

<pre><code class="scala" >Writer[A]

A => Unit
</code></pre>
</div>

</section>
<section id="slide-org0cfe54e">
<h4 id="org0cfe54e">State</h4>
<div class="org-src-container">

<pre><code class="scala" >State[S, A]

S => (A, S)
</code></pre>
</div>

</section>
<section id="slide-orgbf9ea3d">
<h4 id="orgbf9ea3d">IO</h4>
<div class="org-src-container">

<pre><code class="scala" >IO[A]

for { 
  name <- IO { readLine("What is your name?") }
  _    <- IO { print(s"Hello, $name") }
} yield ()
</code></pre>
</div>

</section>
<section id="slide-orgfee60a5">
<h4 id="orgfee60a5">Stream</h4>
<p>
(specifically, <code>fs2.Stream</code>)
</p>
<div class="org-src-container">

<pre><code class="scala" >Stream[F[_], A]
</code></pre>
</div>

<p>
<a href="https://github.com/functional-streams-for-scala/fs2">https://github.com/functional-streams-for-scala/fs2</a>
</p>

</section>
<section id="slide-org8ce71e0">
<h4 id="org8ce71e0">Free</h4>
<p class="fragment">
More on this later&#x2026; 
</p>

</section>
</section>
<section>
<section id="slide-orge3a24d8">
<h3 id="orge3a24d8">Additional Resources</h3>
<ul>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a></li>
<li><a href="https://www.manning.com/books/functional-programming-in-scala">Functional Programming in Scala</a></li>
<li><a href="http://learnyouahaskell.com/">Learn You A Haskell For Great Good</a></li>
<li><a href="http://eed3si9n.com/learning-scalaz/index.html">Learning Scalaz</a>/<a href="http://eed3si9n.com/herding-cats/">Herding Cats</a></li>

</ul>

</section>
</section>
<section>
<section id="slide-orge6419c1">
<h2 id="orge6419c1">?</h2>
<div class="outline-text-2" id="text-orge6419c1">
</div>
</section>
</section>
<section>
<section id="slide-org0ee9c87">
<h3 id="org0ee9c87">Thank You!</h3>
<ul>
<li>Bill Carlson</li>
<li><a href="https://twitter.com/coacoas">@coacoas</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="./reveal.js/lib/js/head.min.js"></script>
<script src="./reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: './reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: './reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
